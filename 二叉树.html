<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>二叉树</title>
  </head>
  <body>
    <script>
      /**
       * 什么是二叉树
       如果树中的每个节点的最多有两个子节点，那么这样的树就称为二叉树
       或者另外一种表达方式：就是每个节点的度不超过2
       **/

      /**
      几种特殊的二叉树
      满二叉树
      通俗一点说就是每一层的节点都是满的
      满二叉树的特点:叶子节点只出现在最后一层
      非叶子节点的度一定是2,

      什么是完全二叉树

      */

      // 二叉树的遍历
      /**
      树作为非 线性数据结构，在我们读取数据的时候就需要设计遍历，
      所谓遍历就是按照一定的规则来依次访问全部的数据
      二叉树的遍历分为三种遍历方法

      先序遍历
      先访问根节点，再访问左子节点，再访问右子节点
      中序遍历
      先访问左子节点，再访问根节点，再访问右子节点
      后续遍历
      先访问左子节点，再访问右子节点，最后访问根节点
      */
      // 二叉树节点 和二叉树的结构设计
      class Node {
        data = null;
        left = null;
        right = null;
        constructor(data) {
          this.data = data;
        }
      }
      class Tree {
        // 树要有根，最开始为空 root 指向树的根
        root = null;

        // 插入数据
        insert(data) {
          const newNode = new Node(data);
          if (this.root === null) {
            this.root = newNode;
          } else {
            // 如果树不是空的，那么就按照一定的规则来插入数据
            // 比节点小的放在left位置上，
            // 比节点值大的就 放在right位置上
            // 假设这里存放的是数值类型的数据
            let node = this.root;
            // 当节点不为空时就一直找下去
            while (node !== null) {
              if (data < node.data) {
                if (node.left === null) {
                  node.left = newNode;
                  return;
                }
                node = node.left;
              } else {
                if (node.right === null) {
                  node.right = newNode;
                  return;
                }
                node = node.right;
              }
            }
          }
        }

        // 遍历一颗树
        preOrder(node) {
          if (node !== null) {
            // 先访问根节点
            console.log(node);
            this.preOrder(node.left);
            this.preOrder(node.right);
          }
        }

        // 中序遍历
        inOrder(node) {
          if (node) {
            this.inOrder(node.left);
            console.log(node);
            this.inOrder(node.right);
          }
        }

        // 后续遍历
        postOrder(node) {
          if (node !== null) {
            this.postOrder(node.left);
            this.postOrder(node.right);
            console.log(node);
          }
        }
      }
    </script>

    <!--  -->
    <script>
      // test
      let tree = new Tree();
      tree.insert(10);
      tree.insert(9);
      tree.insert(80);
      tree.insert(12);
      tree.insert(78);
      tree.insert(3);
      console.log(tree);
      console.log("这是先序遍历");
      console.log(tree.preOrder(tree.root));
      console.log("这是中序遍历");
      console.log(tree.inOrder(tree.root));
      console.log("这是后序遍历");
      console.log(tree.postOrder(tree.root));
    </script>
  </body>
</html>
